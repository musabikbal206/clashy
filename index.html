<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Clash Royale: QR Multiplayer</title>
    
    <!-- External Libraries for QR and Compression -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/lz-string/1.4.4/lz-string.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/qrcodejs/1.0.0/qrcode.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/jsqr@1.4.0/dist/jsQR.min.js"></script>

    <style>
        @import url('https://fonts.googleapis.com/css2?family=Titan+One&display=swap');
        @import url('https://fonts.googleapis.com/css2?family=Roboto:wght@700;900&display=swap');

        :root {
            --blue: #4789CE;
            --red: #EB4847;
            --hud-bg: #2b2018; /* Dark Wood */
            --gold: #ffce00;
        }

        * {
            box-sizing: border-box;
            touch-action: none;
            user-select: none;
            -webkit-user-select: none;
            font-family: 'Titan One', cursive;
        }

        body, html {
            margin: 0;
            padding: 0;
            width: 100%;
            height: 100%;
            background: #111;
            overflow: hidden;
        }

        #app {
            position: relative;
            width: 100%;
            height: 100%;
            max-width: 550px;
            margin: 0 auto;
            background: #333;
            overflow: hidden;
            box-shadow: 0 0 50px #000;
        }

        /* --- 1. MAIN MENU & UPGRADES --- */
        #menu-layer {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            background: linear-gradient(135deg, #1f3b73, #162447);
            z-index: 300;
            display: flex;
            flex-direction: column;
            overflow-y: auto; 
        }

        .menu-header {
            padding: 20px;
            text-align: center;
            background: rgba(0,0,0,0.2);
            flex-shrink: 0;
        }

        .game-title {
            font-size: 40px; color: #ffce00;
            text-shadow: 0 4px 0 #b35900, 0 10px 10px rgba(0,0,0,0.5);
            margin: 0; line-height: 1;
        }

        .player-stats {
            margin-top: 10px;
            color: #fff; font-family: 'Roboto', sans-serif;
            font-size: 16px; display: flex; justify-content: center; gap: 20px;
        }
        .stat-badge { background: #000; padding: 5px 15px; border-radius: 15px; border: 1px solid #555; }

        /* Collection Grid */
        .collection-grid {
            padding: 15px;
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 10px;
            overflow-y: auto;
            flex: 1;
        }

        .collection-card {
            background: #7a8c99;
            border: 3px solid #222;
            border-radius: 8px;
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 10px 5px;
            position: relative;
            box-shadow: 0 4px 0 #111;
        }
        .collection-card.rare { background: #ffbe4d; border-color: #8a5a00; }
        .collection-card.epic { background: #d000ff; border-color: #4a005c; }

        .c-lvl-badge {
            position: absolute; top: -5px; left: -5px;
            background: #222; color: #fff; font-size: 12px;
            padding: 2px 6px; border-radius: 4px; border: 1px solid #fff;
            font-family: 'Roboto', sans-serif;
        }

        .upgrade-btn {
            margin-top: 5px;
            background: #5D9E44;
            border: none; border-bottom: 3px solid #3e6b2c;
            border-radius: 4px;
            color: #fff; font-size: 10px;
            padding: 4px 8px; cursor: pointer;
            width: 100%; font-family: 'Roboto', sans-serif;
        }
        .upgrade-btn:active { transform: translateY(2px); border-bottom-width: 0; }
        .upgrade-btn.cant-afford { filter: grayscale(1); opacity: 0.6; }

        .play-btn-container {
            padding: 20px;
            background: rgba(0,0,0,0.4);
            display: flex; justify-content: center;
            flex-shrink: 0;
            gap: 10px;
        }
        .btn-main {
            background: #ffce00; color: #5c3a00;
            font-size: 20px; padding: 15px 20px;
            border: none; border-bottom: 6px solid #b38b00; border-radius: 12px;
            box-shadow: 0 10px 20px rgba(0,0,0,0.3);
            flex: 1;
        }
        .btn-blue { background: #4789CE; color: #fff; border-bottom-color: #2a5a8a; }
        .btn-main:active { transform: translateY(4px); border-bottom-width: 2px; box-shadow: none; }

        /* --- 2. QR MULTIPLAYER LOBBY --- */
        #mp-lobby {
            display: none;
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: #111; z-index: 400;
            flex-direction: column; padding: 20px; color: #fff;
        }
        
        .qr-container { 
            background: #fff; padding: 10px; border-radius: 8px; 
            margin: 10px auto; display: inline-block; 
        }
        #qrcode {
            /* Placeholder for generated QR */
        }
        
        #camera-container {
            width: 100%; max-width: 300px; height: 250px; 
            background: #000; margin: 10px auto; 
            position: relative; border: 2px solid #ffce00; 
            border-radius: 8px; overflow: hidden;
        }
        video { width: 100%; height: 100%; object-fit: cover; }
        
        .status-txt { text-align: center; color: #aaa; font-size: 14px; margin: 10px 0; font-family: 'Roboto'; }
        .step-title { color: #ffce00; font-size: 20px; text-align: center; margin-bottom: 5px; }

        /* --- 3. GAME SCREEN --- */
        #game-view {
            display: none;
            width: 100%; height: 100%;
            position: relative;
        }

        canvas { display: block; width: 100%; height: 100%; background: #5D9E44; }

        /* --- 4. HUD (Fixed Height & Visibility) --- */
        #hud {
            position: absolute; bottom: 0; left: 0; width: 100%;
            height: 200px;
            background: var(--hud-bg);
            border-top: 4px solid #1a120d;
            display: flex; flex-direction: column;
            padding: 10px;
            z-index: 100;
        }

        .hud-top {
            height: 30px; display: flex; align-items: center; margin-bottom: 8px;
        }
        .elixir-bar {
            flex: 1; height: 24px; background: #111;
            border: 2px solid #555; border-radius: 12px;
            position: relative; overflow: hidden;
        }
        .elixir-fill {
            height: 100%; width: 50%;
            background: linear-gradient(90deg, #d946ef, #a855f7);
            transition: width 0.1s linear;
        }
        .elixir-txt {
            position: absolute; right: 10px; top: 2px;
            font-family: 'Roboto', sans-serif; color: #fff; font-size: 14px;
        }

        /* Hand Container - Explicit Height to fix visibility */
        .hud-bottom {
            flex: 1;
            display: flex;
            gap: 10px;
            height: 110px; /* Force height */
            min-height: 110px;
        }

        .next-card-slot {
            width: 60px;
            background: rgba(0,0,0,0.2);
            border: 1px dashed #777; border-radius: 8px;
            display: flex; flex-direction: column; align-items: center; justify-content: center;
        }
        .next-lbl { font-size: 10px; color: #aaa; margin-bottom: 4px; font-family: sans-serif; }

        #card-hand {
            flex: 1; display: flex; gap: 8px; height: 100%;
        }

        .card {
            flex: 1; height: 100%; /* Fill parent height */
            background: #7a8c99;
            border: 2px solid #222; border-radius: 6px;
            position: relative; cursor: pointer;
            display: flex; flex-direction: column; align-items: center; justify-content: center;
            box-shadow: 0 4px 0 #151515;
            transition: transform 0.1s;
        }
        .card:active { transform: translateY(4px); box-shadow: none; }
        .card.selected { transform: translateY(-12px); border-color: #fff; z-index: 10; box-shadow: 0 10px 20px rgba(0,0,0,0.5); }
        .card.disabled { filter: grayscale(1); opacity: 0.6; }
        
        /* Rarity Styles */
        .card.common { background: #8d99ae; }
        .card.rare { background: #ffbe4d; border-color: #8a5a00; }
        .card.epic { background: #d000ff; border-color: #4a005c; }

        .cost-bubble {
            position: absolute; top: -6px; left: -6px;
            width: 22px; height: 22px; background: #d946ef;
            border: 2px solid #fff; border-radius: 50%;
            display: flex; justify-content: center; align-items: center;
            color: #fff; font-size: 12px; font-family: 'Roboto', sans-serif;
            box-shadow: 0 2px 2px rgba(0,0,0,0.5);
        }
        .c-icon { font-size: 32px; filter: drop-shadow(0 2px 2px rgba(0,0,0,0.3)); }
        .c-name { font-size: 9px; color: #fff; margin-top: 2px; font-family: 'Roboto', sans-serif; text-transform: uppercase; }
        .c-lvl { position: absolute; bottom: 2px; right: 4px; font-size: 10px; color: #fff; font-family:'Roboto',sans-serif; text-shadow:1px 1px 0 #000; }

        /* Result Screen */
        #result-screen {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.85);
            z-index: 500; display: none;
            flex-direction: column; align-items: center; justify-content: center;
        }
        .result-txt { font-size: 50px; color: #fff; margin-bottom: 20px; }
        .crowns-row { display: flex; gap: 15px; margin-bottom: 30px; font-size: 50px; filter: grayscale(1); opacity: 0.3; }
        .crown-active { filter: grayscale(0); opacity: 1; text-shadow: 0 0 20px gold; }
        
        .hidden { display: none !important; }

    </style>
</head>
<body>

<div id="app">
    <!-- 1. MENU & COLLECTION -->
    <div id="menu-layer">
        <div class="menu-header">
            <div class="game-title">CLASH<br>ROYALE</div>
            <div class="player-stats">
                <div class="stat-badge">üí∞ <span id="gold-display">1000</span></div>
                <div class="stat-badge">üèÜ 0</div>
            </div>
        </div>
        
        <div class="collection-grid" id="collection-grid">
            <!-- Cards injected via JS -->
        </div>

        <div class="play-btn-container">
            <button class="btn-main" onclick="APP.startBattle('single')">SOLO</button>
            <button class="btn-main btn-blue" onclick="QR_UI.openLobby()">VS FRIEND</button>
        </div>
    </div>

    <!-- 2. QR LOBBY -->
    <div id="mp-lobby">
        <div class="menu-header" style="padding:10px; background:none">
            <div class="game-title" style="font-size:24px;">CONNECTION</div>
        </div>

        <!-- Role Selection -->
        <div id="role-select" style="display:flex; gap:10px; margin-top:20px;">
            <button class="btn-main btn-blue" onclick="QR_UI.startHost()">HOST GAME</button>
            <button class="btn-main" onclick="QR_UI.startJoin()">JOIN GAME</button>
        </div>

        <!-- QR Display Area (For sending info) -->
        <div id="qr-area" class="hidden" style="text-align:center;">
            <div class="step-title" id="qr-title">SCAN THIS</div>
            <div class="qr-container">
                <div id="qrcode"></div>
            </div>
            <div class="status-txt" id="qr-desc">Waiting for opponent...</div>
        </div>

        <!-- Camera Area (For receiving info) -->
        <div id="cam-area" class="hidden">
            <div class="step-title">SCAN OPPONENT</div>
            <div id="camera-container">
                <video id="scan-video" playsinline></video>
            </div>
            <div class="status-txt">Point camera at opponent's QR code</div>
        </div>

        <button class="upgrade-btn" style="background:#444; margin-top:auto; padding:15px; font-size:14px" onclick="QR_UI.close()">CANCEL</button>
    </div>

    <!-- 3. BATTLE VIEW -->
    <div id="game-view">
        <canvas id="game-canvas"></canvas>
        <div id="hud">
            <div class="hud-top">
                <div class="elixir-bar">
                    <div id="elixir-fill" class="elixir-fill"></div>
                    <div id="elixir-val" class="elixir-txt">5</div>
                </div>
            </div>
            <div class="hud-bottom">
                <div class="next-card-slot">
                    <span class="next-lbl">NEXT</span>
                    <div id="next-icon" style="font-size:24px">?</div>
                </div>
                <div id="card-hand"></div>
            </div>
        </div>
    </div>

    <!-- 4. RESULT SCREEN -->
    <div id="result-screen">
        <div id="res-title" class="result-txt">VICTORY!</div>
        <div class="crowns-row">
            <span id="c1">üëë</span><span id="c2">üëë</span><span id="c3">üëë</span>
        </div>
        <div style="color:#ffce00; margin-bottom:20px; font-family:'Roboto',sans-serif">+ 50 GOLD</div>
        <button class="btn-main" onclick="APP.returnToMenu()">OK</button>
    </div>
</div>

<!-- Hidden Canvas for Video Processing -->
<canvas id="scan-canvas" style="display:none"></canvas>

<script>
/**
 * CLASH ROYALE: QR EDITION
 */

const CONFIG = {
    FPS: 60,
    ELIXIR_RATE: 2.8,
    HUD_HEIGHT: 200,
    COLORS: { BLUE: '#4789CE', RED: '#EB4847', GRASS: '#4BA636', RIVER: '#3FA7D6', BRIDGE: '#8F7156', DIRT: '#967353' }
};

// Player Data
const PLAYER = {
    gold: 1000,
    cards: {
        KNIGHT: { level: 1 },
        ARCHER: { level: 1 },
        GIANT:  { level: 1 },
        SKELLIES:{ level: 1 },
        FIREBALL:{ level: 1 },
        ARROWS:  { level: 1 },
        WIZARD:  { level: 1 },
        PEKKA:   { level: 1 }
    }
};

// Base Stats
const BASE_CARDS = {
    KNIGHT: { type:'unit', rarity:'common', name:'Knight', cost:3, hp:900, dmg:90, speed:45, range:20, count:1, icon:'‚öîÔ∏è' },
    ARCHER: { type:'unit', rarity:'common', name:'Archers', cost:3, hp:300, dmg:60, speed:55, range:140, count:2, icon:'üèπ' },
    GIANT:  { type:'unit', rarity:'rare',   name:'Giant',  cost:5, hp:2600, dmg:150, speed:25, range:20, count:1, icon:'üóø' },
    SKELLIES:{ type:'unit', rarity:'common', name:'Skel', cost:1, hp:60, dmg:50, speed:70, range:20, count:3, icon:'üíÄ' },
    FIREBALL:{ type:'spell', rarity:'rare', name:'Fireball', cost:4, dmg:350, radius:70, icon:'üî•', color:'#ff5500' },
    ARROWS:  { type:'spell', rarity:'common', name:'Arrows', cost:3, dmg:120, radius:110, icon:'‚û¥', color:'#ffcc00' },
    WIZARD:  { type:'unit', rarity:'rare',   name:'Wizard', cost:5, hp:600, dmg:140, speed:45, range:120, count:1, icon:'üßô‚Äç‚ôÇÔ∏è' },
    PEKKA:   { type:'unit', rarity:'epic',   name:'P.E.K.K.A', cost:7, hp:2200, dmg:450, speed:30, range:20, count:1, icon:'ü§ñ' }
};

const DECK_KEYS = Object.keys(BASE_CARDS);

// --- MULTIPLAYER NETWORK LAYER (WebRTC) ---
const MP = {
    peer: null,
    channel: null,
    isHost: false,
    active: false,
    
    init: function(isHost) {
        this.isHost = isHost;
        this.active = true;
        
        // STUN server helps find public IP. Google's is free/reliable.
        const config = { iceServers: [{ urls: "stun:stun.l.google.com:19302" }] };
        this.peer = new RTCPeerConnection(config);

        this.peer.onicecandidate = (e) => {
            if (!e.candidate) {
                // Done gathering candidates. Now we have the full connection info.
                // Compress it to make the QR code smaller.
                const data = JSON.stringify(this.peer.localDescription);
                const compressed = LZString.compressToBase64(data);
                
                // Show this QR to the other player
                const title = isHost ? "HOST: SCAN ME" : "GUEST: SCAN ME";
                QR_UI.showQR(compressed, title);
                
                // If we are Host, we immediately start scanning for the Guest's Answer
                if(isHost) {
                    QR_UI.startScanning();
                }
            }
        };

        if (isHost) {
            // Host creates the data channel
            this.channel = this.peer.createDataChannel("game");
            this.setupChannel();
            this.peer.createOffer().then(o => this.peer.setLocalDescription(o));
        } else {
            // Guest waits for data channel
            this.peer.ondatachannel = (e) => {
                this.channel = e.channel;
                this.setupChannel();
            };
        }
    },

    setupChannel: function() {
        this.channel.onopen = () => {
            // Connection established!
            QR_UI.stopScanning();
            document.getElementById('mp-lobby').style.display = 'none';
            
            // Start the game with appropriate role
            APP.startBattle(this.isHost ? 'host' : 'guest');
        };
        
        this.channel.onmessage = (e) => {
            // Received data from other player
            const msg = JSON.parse(e.data);
            if (APP.game) APP.game.handleNetworkMsg(msg);
        };
    },

    handleScan: function(dataStr) {
        // Called when the camera sees a QR code
        try {
            const decompressed = LZString.decompressFromBase64(dataStr);
            if(!decompressed) return false;
            
            const desc = JSON.parse(decompressed);
            this.peer.setRemoteDescription(new RTCSessionDescription(desc));
            
            if (!this.isHost && desc.type === 'offer') {
                // Guest scanned Host's Offer -> Generate Answer
                this.peer.createAnswer().then(a => this.peer.setLocalDescription(a));
                return true; // Scan success
            }
            
            if (this.isHost && desc.type === 'answer') {
                // Host scanned Guest's Answer -> Connection should open soon
                return true; // Scan success
            }
            
        } catch(e) {
            console.error("QR Scan Error", e);
        }
        return false;
    },

    send: function(data) {
        if (this.channel && this.channel.readyState === 'open') {
            this.channel.send(JSON.stringify(data));
        }
    }
};

// --- QR UI MANAGER ---
const QR_UI = {
    stream: null,
    scanning: false,

    openLobby: function() {
        document.getElementById('mp-lobby').style.display = 'flex';
        // Reset UI state
        document.getElementById('role-select').classList.remove('hidden');
        document.getElementById('qr-area').classList.add('hidden');
        document.getElementById('cam-area').classList.add('hidden');
    },
    
    close: function() {
        this.stopScanning();
        if(MP.peer) {
            MP.peer.close();
            MP.peer = null;
            MP.active = false;
        }
        document.getElementById('mp-lobby').style.display = 'none';
    },

    startHost: function() {
        document.getElementById('role-select').classList.add('hidden');
        MP.init(true);
    },

    startJoin: function() {
        document.getElementById('role-select').classList.add('hidden');
        MP.init(false);
        // Guest needs to scan first
        this.startScanning();
    },

    showQR: function(data, title) {
        document.getElementById('qr-area').classList.remove('hidden');
        document.getElementById('qr-title').innerText = title;
        document.getElementById('qrcode').innerHTML = ""; // Clear old
        
        new QRCode(document.getElementById("qrcode"), {
            text: data,
            width: 180,
            height: 180,
            colorDark : "#000000",
            colorLight : "#ffffff",
            correctLevel : QRCode.CorrectLevel.L
        });
    },

    startScanning: function() {
        document.getElementById('cam-area').classList.remove('hidden');
        const video = document.getElementById('scan-video');
        const canvas = document.getElementById('scan-canvas');
        const ctx = canvas.getContext('2d');
        
        navigator.mediaDevices.getUserMedia({ video: { facingMode: "environment" } })
        .then(stream => {
            this.stream = stream;
            video.srcObject = stream;
            video.setAttribute("playsinline", true);
            video.play();
            this.scanning = true;
            requestAnimationFrame(tick);
        })
        .catch(e => {
            alert("Camera permission is required for multiplayer!");
            console.error(e);
        });

        const tick = () => {
            if(!this.scanning) return;
            
            if(video.readyState === video.HAVE_ENOUGH_DATA) {
                canvas.height = video.videoHeight;
                canvas.width = video.videoWidth;
                ctx.drawImage(video, 0, 0, canvas.width, canvas.height);
                
                const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
                // Use jsQR library to find code
                const code = jsQR(imageData.data, imageData.width, imageData.height, {
                    inversionAttempts: "dontInvert",
                });
                
                if(code) {
                    if(MP.handleScan(code.data)) {
                        // Success! Stop camera.
                        this.stopScanning();
                    }
                }
            }
            requestAnimationFrame(tick);
        }
    },

    stopScanning: function() {
        this.scanning = false;
        if(this.stream) {
            this.stream.getTracks().forEach(track => track.stop());
            this.stream = null;
        }
        document.getElementById('cam-area').classList.add('hidden');
    }
};

// --- APP LOGIC ---
const APP = {
    game: null,
    
    init: function() {
        this.renderMenu();
    },

    getCardStats: function(key) {
        const base = BASE_CARDS[key];
        const lvl = PLAYER.cards[key].level;
        const mult = Math.pow(1.1, lvl - 1); // 10% per level
        
        return {
            ...base,
            id: key,
            hp: Math.floor(base.hp * mult),
            dmg: Math.floor(base.dmg * mult),
            level: lvl
        };
    },

    getUpgradeCost: function(lvl) {
        return lvl * 100;
    },

    upgradeCard: function(key) {
        const lvl = PLAYER.cards[key].level;
        const cost = this.getUpgradeCost(lvl);
        
        if(PLAYER.gold >= cost) {
            PLAYER.gold -= cost;
            PLAYER.cards[key].level++;
            this.renderMenu();
        }
    },

    renderMenu: function() {
        document.getElementById('gold-display').innerText = PLAYER.gold;
        const grid = document.getElementById('collection-grid');
        grid.innerHTML = '';

        DECK_KEYS.forEach(key => {
            const stats = this.getCardStats(key);
            const cost = this.getUpgradeCost(stats.level);
            const canAfford = PLAYER.gold >= cost;

            const el = document.createElement('div');
            el.className = `collection-card ${stats.rarity}`;
            el.innerHTML = `
                <div class="c-lvl-badge">Lv ${stats.level}</div>
                <div style="font-size:32px; margin:5px 0;">${stats.icon}</div>
                <div style="font-size:12px; color:#fff; font-family:'Roboto',sans-serif; text-transform:uppercase">${stats.name}</div>
                <div style="font-size:10px; color:#eee; margin-bottom:5px">HP:${stats.hp} | DMG:${stats.dmg}</div>
                <button class="upgrade-btn ${!canAfford?'cant-afford':''}" onclick="APP.upgradeCard('${key}')">
                    UPGRADE (${cost}üí∞)
                </button>
            `;
            grid.appendChild(el);
        });
    },

    startBattle: function(mode) {
        document.getElementById('menu-layer').style.display = 'none';
        document.getElementById('game-view').style.display = 'block';
        // Small delay to ensure DOM is ready for Canvas
        setTimeout(() => { this.game = new Game(mode); }, 100);
    },

    returnToMenu: function() {
        document.getElementById('result-screen').style.display = 'none';
        document.getElementById('game-view').style.display = 'none';
        document.getElementById('menu-layer').style.display = 'flex';
        
        if(APP.game) {
            APP.game.stop();
            APP.game = null;
        }
        
        // Disconnect Multiplayer
        if(MP.active) {
            QR_UI.close();
        }

        // Reward
        PLAYER.gold += 50;
        this.renderMenu();
    }
};

// --- GAME CLASSES ---
class Vec2 {
    constructor(x,y) { this.x=x; this.y=y; }
    dist(v) { return Math.hypot(this.x-v.x, this.y-v.y); }
    sub(v) { return new Vec2(this.x-v.x, this.y-v.y); }
    norm() { const m=Math.hypot(this.x,this.y); return m===0?new Vec2(0,0):new Vec2(this.x/m,this.y/m); }
}

class Entity {
    constructor(x, y, team, hp, radius) {
        this.pos = new Vec2(x, y);
        this.team = team;
        this.maxHp = hp;
        this.hp = hp;
        this.radius = radius;
        this.dead = false;
        this.hitFlash = 0;
    }
    takeDamage(amt) {
        this.hp -= amt;
        this.hitFlash = 5;
        if(this.hp <= 0) { this.hp = 0; this.dead = true; }
    }
}

class Unit extends Entity {
    constructor(x, y, team, stats, game) {
        super(x, y, team, stats.hp, 14);
        this.stats = stats;
        this.speed = stats.speed;
        this.icon = stats.icon;
        this.attackTimer = 0;
        this.lane = x < game.width/2 ? 'left' : 'right';
        this.state = 'IDLE';
        this.calcState(game);
    }
    calcState(game) {
        const rTop = game.riverY - 25;
        const rBot = game.riverY + 25;
        const isBlue = this.team === 'blue';
        let needCross = false;
        if(isBlue && this.pos.y > rBot) needCross = true;
        if(!isBlue && this.pos.y < rTop) needCross = true;
        this.state = needCross ? 'BRIDGE' : 'HUNT';
    }
    update(dt, enemies, game) {
        if(this.dead) return;
        if(this.hitFlash>0) this.hitFlash--;
        this.attackTimer -= dt;

        let target=null, closest=180;
        for(const e of enemies) {
            if(e.dead) continue;
            const d = this.pos.dist(e.pos);
            if(d<closest) { closest=d; target=e; }
        }

        if(target && this.pos.dist(target.pos) <= this.stats.range + target.radius) {
            if(this.attackTimer <= 0) {
                if(this.stats.range>30) game.addProj(this.pos, target, this.stats.dmg);
                else target.takeDamage(this.stats.dmg);
                this.attackTimer = 1.2;
            }
            return;
        }

        let dest = null;
        const bX = this.lane==='left' ? game.bridgeLeftX : game.bridgeRightX;
        const rTop = game.riverY - 35, rBot = game.riverY + 35;
        const isBlue = this.team==='blue';

        if(this.state === 'BRIDGE') {
            const entryY = isBlue ? rBot + 10 : rTop - 10;
            dest = new Vec2(bX, entryY);
            if(this.pos.dist(dest) < 15) this.state = 'CROSS';
        } 
        else if(this.state === 'CROSS') {
            const exitY = isBlue ? rTop - 10 : rBot + 10;
            dest = new Vec2(bX, exitY);
            if(Math.abs(this.pos.x - bX) > 5) this.pos.x += (bX - this.pos.x)*5*dt;
            if(this.pos.dist(dest) < 15) this.state = 'HUNT';
        }
        else {
            if(target) dest = target.pos;
            else {
                const ts = isBlue ? game.redTowers : game.blueTowers;
                const idx = this.lane==='left' ? 0 : 1;
                dest = (!ts[idx].dead) ? ts[idx].pos : ts[2].pos;
            }
        }

        if(dest) {
            const dir = dest.sub(this.pos).norm();
            this.pos.x += dir.x * this.speed * dt;
            this.pos.y += dir.y * this.speed * dt;
        }
    }
    draw(ctx) {
        if(this.dead) return;
        ctx.fillStyle = 'rgba(0,0,0,0.3)';
        ctx.beginPath(); ctx.ellipse(this.pos.x, this.pos.y+6, this.radius, this.radius*0.6, 0, 0, Math.PI*2); ctx.fill();
        ctx.fillStyle = this.hitFlash>0?'#fff':(this.team==='blue'?CONFIG.COLORS.BLUE:CONFIG.COLORS.RED);
        ctx.beginPath(); ctx.arc(this.pos.x, this.pos.y, this.radius, 0, Math.PI*2); ctx.fill();
        ctx.strokeStyle = '#fff'; ctx.lineWidth = 2; ctx.stroke();
        ctx.font = '16px serif'; ctx.textAlign='center'; ctx.textBaseline='middle';
        ctx.fillText(this.icon, this.pos.x, this.pos.y);
        const pct = this.hp/this.maxHp;
        if(pct<1) {
            ctx.fillStyle='#333'; ctx.fillRect(this.pos.x-10, this.pos.y-22, 20, 4);
            ctx.fillStyle=this.team==='blue'?'#4f4':'#f44'; ctx.fillRect(this.pos.x-10, this.pos.y-22, 20*pct, 4);
        }
    }
}

class Tower extends Entity {
    constructor(x, y, team, type) {
        super(x, y, team, type==='king'?3000:2000, type==='king'?32:24);
        this.type = type;
        this.reload = 0;
        this.range = 210;
    }
    update(dt, enemies, game) {
        if(this.dead) return;
        if(this.hitFlash>0) this.hitFlash--;
        this.reload -= dt;
        if(this.reload <= 0) {
            let target=null, closest=this.range;
            for(const e of enemies) {
                if(e.dead) continue;
                const d = this.pos.dist(e.pos);
                if(d<closest) { closest=d; target=e; }
            }
            if(target) {
                game.addProj(this.pos, target, 80);
                this.reload = 0.8;
            }
        }
    }
    draw(ctx) {
        if(this.dead) { ctx.fillStyle='#444'; ctx.beginPath(); ctx.arc(this.pos.x, this.pos.y, 10, 0, Math.PI*2); ctx.fill(); return; }
        ctx.fillStyle = this.hitFlash>0?'#fff':(this.team==='blue'?CONFIG.COLORS.BLUE:CONFIG.COLORS.RED);
        ctx.strokeStyle = '#222'; ctx.lineWidth = 3;
        ctx.beginPath();
        if(this.type==='king') ctx.rect(this.pos.x-this.radius, this.pos.y-this.radius, this.radius*2, this.radius*2);
        else ctx.arc(this.pos.x, this.pos.y, this.radius, 0, Math.PI*2);
        ctx.fill(); ctx.stroke();
        ctx.fillStyle='#fff'; ctx.font='20px serif'; ctx.textAlign='center'; ctx.textBaseline='middle';
        ctx.fillText(this.type==='king'?'‚ôî':'‚ôï', this.pos.x, this.pos.y);
        const pct = this.hp/this.maxHp;
        ctx.fillStyle='#333'; ctx.fillRect(this.pos.x-15, this.pos.y-this.radius-10, 30, 5);
        ctx.fillStyle=this.team==='blue'?'#4f4':'#f44'; ctx.fillRect(this.pos.x-15, this.pos.y-this.radius-10, 30*pct, 5);
    }
}

class Projectile {
    constructor(pos, target, dmg) {
        this.pos = new Vec2(pos.x, pos.y);
        this.target = target;
        this.dmg = dmg;
        this.active = true;
    }
    update(dt) {
        if(!this.active) return;
        const dir = this.target.pos.sub(this.pos).norm();
        this.pos.x += dir.x * 450 * dt;
        this.pos.y += dir.y * 450 * dt;
        if(this.pos.dist(this.target.pos) < 15) {
            this.target.takeDamage(this.dmg);
            this.active = false;
        }
    }
    draw(ctx) { if(!this.active) return; ctx.fillStyle='#ff0'; ctx.beginPath(); ctx.arc(this.pos.x, this.pos.y, 5, 0, Math.PI*2); ctx.fill(); }
}

class Effect {
    constructor(x, y, color, r) {
        this.pos = new Vec2(x, y);
        this.color = color;
        this.maxR = r;
        this.t = 0;
        this.active = true;
    }
    update(dt) { this.t += dt; if(this.t > 0.4) this.active = false; }
    draw(ctx) {
        ctx.globalAlpha = 1 - (this.t/0.4); ctx.fillStyle = this.color;
        ctx.beginPath(); ctx.arc(this.pos.x, this.pos.y, (this.t/0.4)*this.maxR, 0, Math.PI*2); ctx.fill();
        ctx.globalAlpha = 1;
    }
}

class FloatingCrown {
    constructor(x, y) { this.x=x; this.y=y; this.life=0; this.active=true; }
    update(dt) { this.life+=dt; this.y-=50*dt; if(this.life>1.5) this.active=false; }
    draw(ctx) {
        ctx.save(); ctx.globalAlpha = Math.max(0,1-(this.life/1.5));
        ctx.font='40px serif'; ctx.textAlign='center'; ctx.fillText('üëë', this.x, this.y); ctx.restore();
    }
}

// --- GAME CORE LOGIC ---
class Game {
    constructor(mode) {
        this.mode = mode; // 'single', 'host', 'guest'
        this.isGuest = (mode === 'guest');
        
        this.canvas = document.getElementById('game-canvas');
        this.ctx = this.canvas.getContext('2d');
        this.running = true;
        this.resize();
        
        this.elixir = 5;
        this.elixirTimer = 0;
        this.gameOver = false;
        
        const k = [...DECK_KEYS, ...DECK_KEYS];
        this.shuffle(k);
        this.deck = k;
        this.hand = [this.deck.pop(), this.deck.pop(), this.deck.pop(), this.deck.pop()];
        this.nextCard = this.deck.pop();
        this.selectedIdx = -1;

        this.blueCrowns = 0;
        this.redCrowns = 0;
        this.projs = [];
        this.effects = [];
        this.units = [];
        this.floaters = [];

        this.initLevel();
        this.setupInput();
        this.updateDeckUI();

        this.lastTime = performance.now();
        this.aiTimer = 0;
        this.loopId = requestAnimationFrame(t => this.loop(t));
    }

    stop() { this.running = false; cancelAnimationFrame(this.loopId); }
    shuffle(a) { for(let i=a.length-1; i>0; i--){ const j=Math.floor(Math.random()*(i+1)); [a[i],a[j]]=[a[j],a[i]]; } }

    resize() {
        const p = this.canvas.parentElement;
        this.width = this.canvas.width = p.clientWidth;
        this.height = this.canvas.height = p.clientHeight;
        this.playHeight = this.height - CONFIG.HUD_HEIGHT;
        this.riverY = this.playHeight / 2;
        this.bridgeLeftX = this.width * 0.25;
        this.bridgeRightX = this.width * 0.75;
    }

    initLevel() {
        const rY = this.playHeight*0.25;
        this.redTowers = [
            new Tower(this.width*0.25, rY, 'red', 'princess'),
            new Tower(this.width*0.75, rY, 'red', 'princess'),
            new Tower(this.width*0.5, this.playHeight*0.15, 'red', 'king')
        ];
        
        const bY = this.playHeight*0.75;
        this.blueTowers = [
            new Tower(this.width*0.25, bY, 'blue', 'princess'),
            new Tower(this.width*0.75, bY, 'blue', 'princess'),
            new Tower(this.width*0.5, this.playHeight*0.94, 'blue', 'king')
        ];
    }

    addProj(p, t, d) { this.projs.push(new Projectile(p, t, d)); }

    spawn(key, x, y, team) {
        const stats = APP.getCardStats(key);
        if(stats.count===1) this.units.push(new Unit(x,y,team,stats,this));
        else {
            for(let i=0; i<stats.count; i++) {
                const ox=(Math.random()-0.5)*30, oy=(Math.random()-0.5)*30;
                this.units.push(new Unit(x+ox, y+oy, team, stats, this));
            }
        }
    }

    cast(key, x, y, team) {
        const stats = APP.getCardStats(key);
        this.effects.push(new Effect(x, y, stats.color, stats.radius));
        const tgts = team==='blue' ? [...this.redTowers, ...this.units.filter(u=>u.team==='red')] 
                                   : [...this.blueTowers, ...this.units.filter(u=>u.team==='blue')];
        tgts.forEach(t => {
            if(!t.dead && t.pos.dist(new Vec2(x,y)) <= stats.radius) t.takeDamage(stats.dmg);
        });
    }

    // --- NETWORK: HANDLE MESSAGES FROM OTHER PLAYER ---
    handleNetworkMsg(msg) {
        if(msg.type === 'SPAWN') {
            // Spawn the opponent's unit visually
            const { key, x, y, team } = msg;
            
            // Check type (Unit vs Spell)
            const stats = APP.getCardStats(key);
            if(stats.type === 'unit') {
                this.spawn(key, x, y, team);
            } else {
                this.cast(key, x, y, team);
            }
        }
    }

    update(dt) {
        if(this.gameOver) return;
        this.elixirTimer += dt;
        if(this.elixirTimer > CONFIG.ELIXIR_RATE) {
            this.elixir = Math.min(this.elixir+1, 10);
            this.elixirTimer = 0;
            this.updateDeckUI();
        }
        document.getElementById('elixir-fill').style.width = (this.elixir/10)*100 + '%';
        document.getElementById('elixir-val').innerText = Math.floor(this.elixir);

        // AI Logic: ONLY in Single Player
        if (this.mode === 'single') {
            this.aiTimer += dt;
            if(this.aiTimer > 4.5) {
                this.aiTimer = 0;
                const uKeys = DECK_KEYS.filter(k => BASE_CARDS[k].type==='unit');
                const k = uKeys[Math.floor(Math.random()*uKeys.length)];
                const x = Math.random()>0.5 ? this.bridgeLeftX : this.bridgeRightX;
                this.spawn(k, x, this.riverY - 80, 'red');
            }
        }

        const allR = [...this.redTowers, ...this.units.filter(u=>u.team==='red')];
        const allB = [...this.blueTowers, ...this.units.filter(u=>u.team==='blue')];

        [...this.redTowers, ...this.blueTowers, ...this.units].forEach(e => e.update(dt, e.team==='blue'?allR:allB, this));
        this.projs.forEach(p => p.update(dt));
        this.effects.forEach(e => e.update(dt));
        this.floaters.forEach(f => f.update(dt));

        this.units = this.units.filter(u => !u.dead);
        this.projs = this.projs.filter(p => p.active);
        this.effects = this.effects.filter(e => e.active);
        this.floaters = this.floaters.filter(f => f.active);

        this.checkCrowns(this.redTowers, 'blue');
        this.checkCrowns(this.blueTowers, 'red');

        // End Game Checks
        let end = false, blueWin = false;
        
        if(this.redTowers[2].dead) { end=true; blueWin=true; }
        else if(this.blueTowers[2].dead) { end=true; blueWin=false; }
        
        if (end) {
            // Determine result text based on who I am playing as
            // Host = Blue, Guest = Red
            let iWon = false;
            if(this.mode === 'single') iWon = blueWin;
            else if(this.isGuest) iWon = !blueWin; // I am Red, so Red winning means I won
            else iWon = blueWin; // I am Host (Blue)

            this.end(iWon ? 'VICTORY!' : 'DEFEAT!', iWon ? '#4f4' : '#f44');
        }
    }

    checkCrowns(towers, team) {
        towers.forEach(t => {
            if(t.dead && !t.cAwarded) {
                t.cAwarded=true; this.floaters.push(new FloatingCrown(t.pos.x, t.pos.y));
                if(team==='blue') this.blueCrowns++; else this.redCrowns++;
            }
        });
    }

    draw() {
        this.ctx.save();
        
        // --- BOARD ROTATION FOR GUEST ---
        // If I am Guest (Red), flip the board so I play from bottom
        if (this.isGuest) {
            this.ctx.translate(this.width, this.height);
            this.ctx.rotate(Math.PI);
            // Counteract HUD space so map is centered correctly in rotation
            this.ctx.translate(0, -CONFIG.HUD_HEIGHT); 
        }

        this.ctx.fillStyle = CONFIG.COLORS.GRASS;
        this.ctx.fillRect(0,0,this.width,this.height);
        this.ctx.fillStyle = 'rgba(0,0,0,0.05)';
        for(let x=0; x<this.width; x+=40) this.ctx.fillRect(x,0,2,this.height);

        this.ctx.fillStyle = CONFIG.COLORS.RIVER;
        this.ctx.fillRect(0, this.riverY-30, this.width, 60);

        this.ctx.fillStyle = CONFIG.COLORS.BRIDGE;
        const bw = 60;
        const db = (x) => {
            this.ctx.fillRect(x-bw/2, this.riverY-35, bw, 70);
            this.ctx.strokeStyle='#4a3b2b'; this.ctx.lineWidth=2;
            for(let i=0; i<=70; i+=10) {
                this.ctx.beginPath(); this.ctx.moveTo(x-bw/2, this.riverY-35+i); this.ctx.lineTo(x+bw/2, this.riverY-35+i); this.ctx.stroke();
            }
        }
        db(this.bridgeLeftX); db(this.bridgeRightX);

        const all = [...this.redTowers, ...this.blueTowers, ...this.units, ...this.projs];
        all.sort((a,b) => a.pos.y - b.pos.y);
        all.forEach(e => e.draw(this.ctx));
        this.effects.forEach(e => e.draw(this.ctx));
        this.floaters.forEach(f => f.draw(this.ctx));

        if(this.selectedIdx !== -1) {
            const k = this.hand[this.selectedIdx];
            const d = BASE_CARDS[k];
            this.ctx.fillStyle = 'rgba(255,255,255,0.1)';
            
            if(d.type==='unit') {
                // Highlight deployment zone
                // Logic: If Guest (Red), my zone is physically Y < River.
                // But since canvas is rotated 180deg, 0 is at "bottom" visually.
                
                const yStart = this.isGuest ? 0 : this.riverY+30;
                const hZone = this.isGuest ? this.riverY-30 : this.height - (this.riverY+30);
                
                this.ctx.fillRect(0, yStart, this.width, hZone);
                this.ctx.strokeStyle='#fff'; this.ctx.setLineDash([5,5]); this.ctx.lineWidth=2;
                
                const lineY = this.isGuest ? this.riverY-30 : this.riverY+30;
                this.ctx.beginPath(); this.ctx.moveTo(0, lineY); this.ctx.lineTo(this.width, lineY); this.ctx.stroke(); 
                this.ctx.setLineDash([]);
            } else {
                this.ctx.fillRect(0,0,this.width,this.height);
            }
        }
        
        this.ctx.restore();
    }

    loop(t) {
        if(!this.running) return;
        const dt = Math.min((t - this.lastTime)/1000, 0.1);
        this.lastTime = t;
        this.update(dt);
        this.draw();
        this.loopId = requestAnimationFrame(tm => this.loop(tm));
    }

    setupInput() {
        const h = (e) => {
            if(this.gameOver || this.selectedIdx===-1) return;
            e.preventDefault();
            const r = this.canvas.getBoundingClientRect();
            const tx = e.touches ? e.touches[0].clientX : e.clientX;
            const ty = e.touches ? e.touches[0].clientY : e.clientY;
            let x = tx - r.left;
            let y = ty - r.top;

            // Coordinate Transformation for Guest
            // If Guest, the screen click (X,Y) needs to be inverted to match world space
            if (this.isGuest) {
                x = this.width - x;
                y = this.height - y;
            }

            const k = this.hand[this.selectedIdx];
            const d = BASE_CARDS[k];
            const myTeam = this.isGuest ? 'red' : 'blue';
            
            let ok = false;
            if (d.type === 'spell') ok = true;
            else {
                // Deployment Rules
                if (myTeam === 'blue' && y > this.riverY+30) ok = true;
                if (myTeam === 'red' && y < this.riverY-30) ok = true;
            }

            if(ok && this.elixir >= d.cost) {
                this.elixir -= d.cost;
                
                // 1. Spawn locally
                if(d.type==='unit') this.spawn(k, x, y, myTeam);
                else this.cast(k, x, y, myTeam);

                // 2. Send to network
                if(this.mode !== 'single') {
                    MP.send({ type: 'SPAWN', key: k, x: x, y: y, team: myTeam });
                }

                if(this.deck.length===0) { const kk=[...DECK_KEYS]; this.shuffle(kk); this.deck=kk; }
                this.hand[this.selectedIdx] = this.nextCard;
                this.nextCard = this.deck.pop();
                
                this.selectedIdx = -1;
                this.updateDeckUI();
            }
        };
        this.canvas.addEventListener('mousedown', h);
        this.canvas.addEventListener('touchstart', h, {passive:false});
    }

    updateDeckUI() {
        const h = document.getElementById('card-hand');
        h.innerHTML = '';
        this.hand.forEach((k, i) => {
            const stats = APP.getCardStats(k);
            const el = document.createElement('div');
            const affordable = this.elixir >= stats.cost;
            el.className = `card ${stats.rarity} ${this.selectedIdx===i?'selected':''} ${!affordable?'disabled':''}`;
            el.innerHTML = `
                <div class="cost-bubble">${stats.cost}</div>
                <div class="c-icon">${stats.icon}</div>
                <div class="c-name">${stats.name}</div>
                <div class="c-lvl">Lv${stats.level}</div>
            `;
            el.onclick = () => { if(affordable) { this.selectedIdx=(this.selectedIdx===i)?-1:i; this.updateDeckUI(); } };
            h.appendChild(el);
        });
        document.getElementById('next-icon').innerText = BASE_CARDS[this.nextCard].icon;
    }

    end(msg, col) {
        this.gameOver = true;
        document.getElementById('res-title').innerText = msg;
        document.getElementById('res-title').style.color = col;
        
        // Show crowns
        // If I am Guest, I want to know my score (Red Crowns)
        const myCrowns = this.isGuest ? this.redCrowns : this.blueCrowns;

        if(myCrowns>=1) document.getElementById('c1').classList.add('crown-active');
        if(myCrowns>=2) document.getElementById('c2').classList.add('crown-active');
        if(myCrowns>=3) document.getElementById('c3').classList.add('crown-active');
        
        document.getElementById('result-screen').style.display = 'flex';
    }
}

// Init
window.onload = () => APP.init();

</script>
</body>
</html>


